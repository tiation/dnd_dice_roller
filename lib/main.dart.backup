import 'package:flutter/material.dart';
import 'dart:math';

void main() {
  runApp(const DnDDiceRollerApp());
}

class DnDDiceRollerApp extends StatelessWidget {
  const DnDDiceRollerApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'D&D 5E Dice Roller',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: const Color(0xFF8B0000), // Dark red theme
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      home: const DiceRollerHome(),
    );
  }
}

class DiceRoll {
  final String id; // Unique identifier for reordering
  final int sides;
  final int count;
  final int modifier;
  final String description;
  final Color color; // Color for theme management
  final String icon; // Icon/emoji for visual identification
  final String category; // Category for organization (e.g., 'combat', 'skill', 'damage')
  final int sortOrder; // For custom ordering
  
  DiceRoll({
    required this.id,
    required this.sides,
    required this.count,
    required this.modifier,
    required this.description,
    required this.color,
    required this.icon,
    required this.category,
    this.sortOrder = 0,
  });
  
  // Factory constructor for creating DiceRoll with generated ID
  factory DiceRoll.create({
    required int sides,
    required int count,
    required int modifier,
    required String description,
    required Color color,
    required String icon,
    required String category,
    int sortOrder = 0,
  }) {
    return DiceRoll(
      id: DateTime.now().millisecondsSinceEpoch.toString() + '_' + (sides * 1000 + count * 100 + modifier).toString(),
      sides: sides,
      count: count,
      modifier: modifier,
      description: description,
      color: color,
      icon: icon,
      category: category,
      sortOrder: sortOrder,
    );
  }
  
  // Copy constructor for creating modified versions
  DiceRoll copyWith({
    String? id,
    int? sides,
    int? count,
    int? modifier,
    String? description,
    Color? color,
    String? icon,
    String? category,
    int? sortOrder,
  }) {
    return DiceRoll(
      id: id ?? this.id,
      sides: sides ?? this.sides,
      count: count ?? this.count,
      modifier: modifier ?? this.modifier,
      description: description ?? this.description,
      color: color ?? this.color,
      icon: icon ?? this.icon,
      category: category ?? this.category,
      sortOrder: sortOrder ?? this.sortOrder,
    );
  }
  
  // Convert to/from JSON for persistence
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'sides': sides,
      'count': count,
      'modifier': modifier,
      'description': description,
      'color': color.value,
      'icon': icon,
      'category': category,
      'sortOrder': sortOrder,
    };
  }
  
  factory DiceRoll.fromJson(Map<String, dynamic> json) {
    return DiceRoll(
      id: json['id'],
      sides: json['sides'],
      count: json['count'],
      modifier: json['modifier'],
      description: json['description'],
      color: Color(json['color']),
      icon: json['icon'],
      category: json['category'],
      sortOrder: json['sortOrder'] ?? 0,
    );
  }
}

class DiceRollerHome extends StatefulWidget {
  const DiceRollerHome({super.key});

  @override
  State<DiceRollerHome> createState() => _DiceRollerHomeState();
}

class _DiceRollerHomeState extends State<DiceRollerHome> with TickerProviderStateMixin {
  final Random _random = Random();
  List<String> _rollHistory = [];
  String _selectedCategory = 'all'; // For filtering by category
  
  // Quick roll presets for 5E with enhanced theming
  final List<DiceRoll> _quickRolls = [
    DiceRoll.create(
      sides: 20,
      count: 1,
      modifier: 0,
      description: 'Attack Roll',
      color: Colors.red,
      icon: '‚öîÔ∏è',
      category: 'combat',
      sortOrder: 1,
    ),
    DiceRoll.create(
      sides: 20,
      count: 1,
      modifier: 0,
      description: 'Skill Check',
      color: Colors.blue,
      icon: 'üéØ',
      category: 'skill',
      sortOrder: 2,
    ),
    DiceRoll.create(
      sides: 20,
      count: 1,
      modifier: 0,
      description: 'Saving Throw',
      color: Colors.green,
      icon: 'üõ°Ô∏è',
      category: 'defense',
      sortOrder: 3,
    ),
    DiceRoll.create(
      sides: 6,
      count: 1,
      modifier: 0,
      description: 'Damage',
      color: Colors.orange,
      icon: 'üí•',
      category: 'damage',
      sortOrder: 4,
    ),
    DiceRoll.create(
      sides: 8,
      count: 1,
      modifier: 0,
      description: 'Longsword',
      color: Colors.purple,
      icon: 'üó°Ô∏è',
      category: 'weapon',
      sortOrder: 5,
    ),
    DiceRoll.create(
      sides: 6,
      count: 2,
      modifier: 0,
      description: 'Greatsword',
      color: Colors.deepPurple,
      icon: '‚öîÔ∏è',
      category: 'weapon',
      sortOrder: 6,
    ),
    DiceRoll.create(
      sides: 10,
      count: 1,
      modifier: 0,
      description: 'Heavy Crossbow',
      color: Colors.brown,
      icon: 'üèπ',
      category: 'weapon',
      sortOrder: 7,
    ),
    DiceRoll.create(
      sides: 8,
      count: 1,
      modifier: 0,
      description: 'Rapier',
      color: Colors.teal,
      icon: 'ü§∫',
      category: 'weapon',
      sortOrder: 8,
    ),
  ];
  
  // Standard dice types
  final List<int> _diceTypes = [4, 6, 8, 10, 12, 20, 100];
  
  int _selectedDice = 20;
  int _diceCount = 1;
  int _modifier = 0;
  
  late AnimationController _rollAnimationController;
  late Animation<double> _rollAnimation;
  
  @override
  void initState() {
    super.initState();
    _rollAnimationController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    _rollAnimation = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(parent: _rollAnimationController, curve: Curves.bounceOut),
    );
  }
  
  @override
  void dispose() {
    _rollAnimationController.dispose();
    super.dispose();
  }
  
  List<int> _rollDice(int sides, int count) {
    return List.generate(count, (index) => _random.nextInt(sides) + 1);
  }
  
  void _performRoll(int sides, int count, int modifier, String description) {
    _rollAnimationController.forward().then((_) {
      _rollAnimationController.reset();
    });
    
    final rolls = _rollDice(sides, count);
    final total = rolls.fold(0, (sum, roll) => sum + roll) + modifier;
    
    String rollText = description.isEmpty ? 
      '${count}d$sides${modifier != 0 ? (modifier > 0 ? '+$modifier' : '$modifier') : ''}' : 
      description;
    
    String resultText = '$rollText: ${rolls.join(' + ')}${modifier != 0 ? (modifier > 0 ? ' + $modifier' : ' - ${-modifier}') : ''} = $total';
    
    if (rolls.length == 1 && sides == 20) {
      if (rolls[0] == 20) {
        resultText += ' üéØ CRITICAL!';
      } else if (rolls[0] == 1) {
        resultText += ' üí• FUMBLE!';
      }
    }
    
    setState(() {
      _rollHistory.insert(0, resultText);
      if (_rollHistory.length > 20) {
        _rollHistory.removeLast();
      }
    });
  }
  
void _clearHistory() {
    setState(() {
      _rollHistory.clear();
    });
  }
  
  List<DiceRoll> _getFilteredRolls() {
    return _quickRolls.where((roll) => _selectedCategory == 'all' || roll.category == _selectedCategory).toList();
  }

  void _sortRollsByOrder() {
    _quickRolls.sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
  }

  void _setCategory(String category) {
    setState(() {
      _selectedCategory = category;
});
  }
  
  void _showEditPresetDialog(DiceRoll? roll) {
    final TextEditingController nameController = TextEditingController(text: roll?.description ?? '');
    final TextEditingController diceController = TextEditingController(text: roll != null ? roll.count.toString() : '1');
    final TextEditingController sidesController = TextEditingController(text: roll != null ? roll.sides.toString() : '20');
    final TextEditingController modifierController = TextEditingController(text: roll != null ? roll.modifier.toString() : '0');
    final TextEditingController iconController = TextEditingController(text: roll?.icon ?? '');
    final TextEditingController categoryController = TextEditingController(text: roll?.category ?? '');
    
    Color selectedColor = roll?.color ?? Colors.grey;
    
    final List<Color> availableColors = [
      Colors.red,
      Colors.blue,
      Colors.green,
      Colors.orange,
      Colors.purple,
      Colors.deepPurple,
      Colors.brown,
      Colors.teal,
      Colors.pink,
      Colors.indigo,
      Colors.grey,
      Colors.amber,
    ];

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) => AlertDialog(
          title: Text(roll == null ? 'Add Quick Roll' : 'Edit Quick Roll'),
          content: SingleChildScrollView(
            child: Column(
              children: [
                TextField(controller: nameController, decoration: InputDecoration(labelText: 'Name')),
                TextField(controller: diceController, keyboardType: TextInputType.number, decoration: InputDecoration(labelText: 'Dice Count')),
                TextField(controller: sidesController, keyboardType: TextInputType.number, decoration: InputDecoration(labelText: 'Dice Sides')),
                TextField(controller: modifierController, keyboardType: TextInputType.number, decoration: InputDecoration(labelText: 'Modifier')),
                TextField(controller: iconController, decoration: InputDecoration(labelText: 'Icon/Emoji')),
                TextField(controller: categoryController, decoration: InputDecoration(labelText: 'Category')),
                const SizedBox(height: 16),
                const Text('Color:', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  children: availableColors.map((color) => GestureDetector(
                    onTap: () => setDialogState(() => selectedColor = color),
                    child: Container(
                      width: 32,
                      height: 32,
                      decoration: BoxDecoration(
                        color: color,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: selectedColor == color ? Colors.white : Colors.transparent,
                          width: 3,
                        ),
                      ),
                    ),
                  )).toList(),
                ),
              ],
            ),
          ),
          actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              setState(() {
                if (roll == null) {
                  _quickRolls.add(DiceRoll.create(
                    sides: int.tryParse(sidesController.text) ?? 20,
                    count: int.tryParse(diceController.text) ?? 1,
                    modifier: int.tryParse(modifierController.text) ?? 0,
                    description: nameController.text,
                    color: selectedColor,
                    icon: iconController.text,
                    category: categoryController.text,
                    sortOrder: _quickRolls.length,
                  ));
                } else {
                  final index = _quickRolls.indexOf(roll!);
                  if (index != -1) {
                    _quickRolls[index] = roll.copyWith(
                      sides: int.tryParse(sidesController.text) ?? roll.sides,
                      count: int.tryParse(diceController.text) ?? roll.count,
                      modifier: int.tryParse(modifierController.text) ?? roll.modifier,
                      description: nameController.text,
                      icon: iconController.text,
                      category: categoryController.text,
                      color: selectedColor,
                    );
                  }
                }
              });
              Navigator.of(context).pop();
            },
            child: const Text('Save'),
          ),
        ],
        ),
      ),
    );
  }

  List<String> getCategories() {
    return ['all', ...{for (var roll in _quickRolls) roll.category}];
  }
  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    final isSmallScreen = screenWidth < 600;
    final isMediumScreen = screenWidth >= 600 && screenWidth < 1200;
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('D&D 5E Dice Roller'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        actions: [
          IconButton(
            icon: const Icon(Icons.clear_all),
            onPressed: _clearHistory,
            tooltip: 'Clear History',
          ),
        ],
      ),
      body: LayoutBuilder(
        builder: (context, constraints) {
          if (isSmallScreen) {
            // Mobile layout - single column
            return SingleChildScrollView(
              child: Column(
                children: [
                  _buildQuickRollSection(),
                  const Divider(),
                  _buildCustomRollSection(),
                  const Divider(),
                  SizedBox(
                    height: 400, // Fixed height for history on mobile
                    child: _buildHistorySection(),
                  ),
                ],
              ),
            );
          } else if (isMediumScreen) {
            // Tablet layout - two columns
            return Row(
              children: [
                Expanded(
                  flex: 1,
                  child: SingleChildScrollView(
                    child: Column(
                      children: [
                        _buildQuickRollSection(),
                        const Divider(),
                        _buildCustomRollSection(),
                      ],
                    ),
                  ),
                ),
                const VerticalDivider(),
                Expanded(
                  flex: 1,
                  child: _buildHistorySection(),
                ),
              ],
            );
          } else {
            // Desktop layout - three columns
            return Row(
              children: [
                Expanded(
                  flex: 1,
                  child: _buildQuickRollSection(),
                ),
                const VerticalDivider(),
                Expanded(
                  flex: 1,
                  child: _buildCustomRollSection(),
                ),
                const VerticalDivider(),
                Expanded(
                  flex: 1,
                  child: _buildHistorySection(),
                ),
              ],
            );
          }
        },
      ),
    );
  }
  
Widget _buildQuickRollSection() {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Quick Rolls',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              IconButton(
                icon: const Icon(Icons.add),
                onPressed: () => _showEditPresetDialog(null),
                tooltip: 'Add Quick Roll',
              ),
            ],
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 400,
            child: ReorderableListView(
              onReorder: (oldIndex, newIndex) {
                setState(() {
                  if (newIndex > oldIndex) {
                    newIndex -= 1;
                  }
                  final item = _quickRolls.removeAt(oldIndex);
                  _quickRolls.insert(newIndex, item);
                  for (int i = 0; i < _quickRolls.length; i++) {
                    _quickRolls[i] = _quickRolls[i].copyWith(sortOrder: i);
                  }
                });
              },
              children: _quickRolls.asMap().entries.map((entry) {
                final index = entry.key;
                final roll = entry.value;
                return Card(
                  key: Key('quick_roll_${roll.id}_$index'),
                  margin: const EdgeInsets.symmetric(vertical: 4),
                  child: ListTile(
                    leading: Text(
                      roll.icon,
                      style: const TextStyle(fontSize: 20),
                    ),
                    title: Text(roll.description),
                    subtitle: Text('${roll.count}d${roll.sides}${roll.modifier != 0 ? (roll.modifier > 0 ? '+${roll.modifier}' : '${roll.modifier}') : ''} (${roll.category})'),
                    trailing: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        IconButton(
                          icon: const Icon(Icons.edit),
                          onPressed: () => _showEditPresetDialog(roll),
                        ),
                        IconButton(
                          icon: const Icon(Icons.delete),
                          onPressed: () {
                            setState(() {
                              _quickRolls.remove(roll);
                            });
                          },
                        ),
                      ],
                    ),
                    onTap: () => _performRoll(roll.sides, roll.count, roll.modifier, roll.description),
                  ),
                );
              }).toList(),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildCustomRollSection() {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Custom Roll',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),
          
          // Dice Selection - Responsive layout
          LayoutBuilder(
            builder: (context, constraints) {
              final screenWidth = MediaQuery.of(context).size.width;
              final isSmallScreen = screenWidth < 600;
              
              if (isSmallScreen) {
                // Stack vertically on small screens
                return Column(
                  children: [
                    _buildDiceSelector(),
                    const SizedBox(height: 16),
                    _buildCountSelector(),
                    const SizedBox(height: 16),
                    _buildModifierSelector(),
                  ],
                );
              } else {
                // Horizontal layout for larger screens
                return Wrap(
                  spacing: 16,
                  runSpacing: 16,
                  children: [
                    _buildDiceSelector(),
                    _buildCountSelector(),
                    _buildModifierSelector(),
                  ],
                );
              }
            },
          ),
          
          const SizedBox(height: 16),
          
          // Roll Button
          Center(
            child: AnimatedBuilder(
              animation: _rollAnimation,
              builder: (context, child) {
                return Transform.scale(
                  scale: 1.0 + (_rollAnimation.value * 0.2),
                  child: ElevatedButton(
                    onPressed: () => _performRoll(_selectedDice, _diceCount, _modifier, ''),
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                      textStyle: const TextStyle(fontSize: 18),
                    ),
                    child: FittedBox(
                      fit: BoxFit.scaleDown,
                      child: Text('Roll ${_diceCount}d$_selectedDice${_modifier != 0 ? (_modifier > 0 ? '+$_modifier' : '$_modifier') : ''}'),
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildDiceSelector() {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Text('Dice: '),
        DropdownButton<int>(
          value: _selectedDice,
          items: _diceTypes.map((dice) => 
            DropdownMenuItem(
              value: dice,
              child: Text('d$dice'),
            )
          ).toList(),
          onChanged: (value) {
            setState(() {
              _selectedDice = value!;
            });
          },
        ),
      ],
    );
  }
  
  Widget _buildCountSelector() {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Text('Count: '),
        SizedBox(
          width: 60,
          child: TextField(
            keyboardType: TextInputType.number,
            onChanged: (value) {
              _diceCount = int.tryParse(value) ?? 1;
            },
            decoration: InputDecoration(
              hintText: _diceCount.toString(),
              border: const OutlineInputBorder(),
              contentPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
            ),
          ),
        ),
      ],
    );
  }
  
  Widget _buildModifierSelector() {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Text('Modifier: '),
        SizedBox(
          width: 60,
          child: TextField(
            keyboardType: TextInputType.number,
            onChanged: (value) {
              _modifier = int.tryParse(value) ?? 0;
            },
            decoration: InputDecoration(
              hintText: _modifier.toString(),
              border: const OutlineInputBorder(),
              contentPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
            ),
          ),
        ),
      ],
    );
  }
  
  Widget _buildHistorySection() {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Roll History',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          Expanded(
            child: _rollHistory.isEmpty
                ? const Center(
                    child: Text(
                      'No rolls yet. Roll some dice!',
                      style: TextStyle(fontSize: 16, color: Colors.grey),
                    ),
                  )
                : ListView.builder(
                    itemCount: _rollHistory.length,
                    itemBuilder: (context, index) {
                      return Card(
                        key: Key('history_$index'),
                        child: ListTile(
                          title: Text(
                            _rollHistory[index],
                            style: TextStyle(
                              fontSize: MediaQuery.of(context).size.width < 600 ? 14 : 16,
                            ),
                          ),
                          leading: CircleAvatar(
                            child: Text('${index + 1}'),
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}
